#!/bin/bash

alias db='cd ~/src/xplat/'
alias db2='cd ~/src/xplat2/'
alias db3='cd ~/src/xplat3/'
alias dbtags='git for-each-ref --shell --sort=creatordate --format="%(refname:short) ->  %(creatordate:format:%x ~ %X %z)" | grep dbapp-ios/'
alias ghd='gh dbx'
alias gpr='gh dbx pr'
alias gprf='gh dbx pr --force-push'
alias gprd='gh dbx pr --draft'
alias ghdm='gh dbx merge --keep-branch'
alias land='gh dbx land --keep-branch'

alias gen='./ios_gen_module_project -o'
alias td='./td'

function b() {
    BUCK_PATH="$(buck root)"
    MY_PATH="$(pwd)"
    TARGET_PATH="/${MY_PATH#$BUCK_PATH}"
    BUILD_PATH=$TARGET_PATH$1
    echo "$BUILD_PATH"
    buckw build "$BUILD_PATH"
}

function vv() {
    buckw query "attrfilter('module_name', '$1', '//...')" | tail -1
}

PATH=$PATH:~/src/GitChildBranchHelpers/bin/
eval "$(direnv hook zsh)"

ssh-add --apple-use-keychain ~/.ssh/id_ed25519_dbx_github > /dev/null 2>&1

# Stacked diffs flow
# run git pull main
# run branch cleanup
# run rebase stacks

alias gpm="git_pull_main"
function git_pull_main() {
    if ! { git diff --cached --exit-code --quiet && git diff --exit-code --quiet; }
    then
        echo "Checkout is dirty!"
        return 1
    fi

    stop_tooling

    git checkout main
    git prune
    git fetch --prune
    git pull --rebase --autostash
    ./td setup --task python3-packages
    ./td sub
    git status
}

alias gbc="git_branch_cleanup"
function git_branch_cleanup() {
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    NC='\033[0m' # No Color

    git checkout main

    for branch in $(git for-each-ref --format='%(refname:short)' refs/heads/ | egrep -v "(main|jboulter)")
    do
        git diff main $branch --exit-code --quiet
        if [ $? -eq 0 ]
        then
            echo -e "${RED}DELETING $branch${NC}"
            git branch -D $branch
        else
            echo -e "${GREEN}Keeping $branch${NC}"
        fi
    done
    echo "Finished cleaning"
}

alias grs="git_rebase_stacks"
function git_rebase_stacks() {
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    NC='\033[0m' # No Color

    if ! { git diff --cached --exit-code --quiet && git diff --exit-code --quiet; }
    then
        echo "Checkout is dirty!"
        return 1
    fi

    git checkout main

    # Nasty, but the intent here is to loop the branches in "tree order" - I want to rebase branches further up the tree first
    # so that any stacked branches will rebase their upstream branches at the same time
    BRANCHES_STRING=$(git log --pretty="format:%D" --graph --branches -10000 | perl -ne 'for (split /[\s,]+/) { print $_ . "\n" if /^[a-z0-9\_]+$/ && !/main/}')

    read -d '' -A BRANCHES <<< "$BRANCHES_STRING"

    echo $BRANCHES
    
    #for branch in $(git for-each-ref --format='%(refname:short)'  --sort='-committerdate' refs/heads/ | egrep -v '^(main|jboulter)')

    for branch in $BRANCHES
    do
        echo -e "${GREEN}*** ${branch}${NC}"
        git checkout $branch
        if [ $? -ne 0 ]
        then
            echo -e "${RED}Skipping ${branch}, cannot checkout${NC}"
        else
            git rebase main --update-refs # -X theirs
            if [ $? -ne 0 ]
            then
                echo -e "${RED}Could not rebase ${branch}, please fix and finish rebase, then re-run.${NC}"
                break
            fi
        fi
    done

    git checkout main
}

function stop_tooling() {
    echo "Killing watchman"
    killall watchman || true

    if [ -f ".buckconfig" ]
    then
        echo "Killing buck"
        buck kill
    fi

    rm -rf .buckconfig.d/.watchman-cookie-*

    if pgrep -qf MacOS/Xcode
    then
        echo "Killing xcode"
        killall -9 Xcode || true
        sleep 2
    fi

    if pgrep -qf MacOS/Xcode
    then
        echo "Killing xcode"
        killall -9 Xcode || true
        sleep 2
    fi
}

alias gcsm="git_cleanup_squash_merged"
function git_cleanup_squash_merged() {
    if ! { git diff --cached --exit-code --quiet && git diff --exit-code --quiet; }
    then
        echo "Checkout is dirty!"
        return 1
    fi
    BRANCH=$1
    if [[ -z "$BRANCH" ]]
    then
        echo "No branch specified"
        return 1
    fi

    echo "Searching for squashed commit..."
    SQUASHED_COMMIT="$(find_matching_squashed_commit "$BRANCH" 2>/dev/null | grep -Eo '^[0-9a-f]{40}$' | head -n1)"
    if [[ -z "$SQUASHED_COMMIT" ]]; then
        echo "Could not locate a matching squashed commit on main." >&2
        return 1
    fi
    echo "Found squashed commit: $SQUASHED_COMMIT"
    echo "--- Commit details ---------------------------"
    git --no-pager log -1 --color --pretty=format:'%C(auto)%h %d %s%nAuthor: %an <%ae>%nDate:   %ad' --date=short "$SQUASHED_COMMIT"
    echo "----------------------------------------------"

    echo "About to start an interactive rebase onto the squashed commit."
    echo "Command: git rebase -i --update-refs --onto $SQUASHED_COMMIT $BRANCH"

    local _confirm
    # Read from the controlling terminal so the prompt always appears even if
    # stdin is being piped from somewhere else.
    read -r -p "Proceed? [Y/n] " _confirm < /dev/tty
    case "$_confirm" in
        [nN][nN]*) echo "Aborted by user." >&2; return 1 ;;
    esac

    git rebase -i --update-refs --onto "$SQUASHED_COMMIT" "$(git merge-base HEAD $BRANCH)"
}

function find_matching_squashed_commit() {
    # Locate the commit on main that represents the squashed version of the
    # given feature BRANCH. Works even when caller is on a different branch â€“
    # we temporarily check out the base branch, do the check, then restore the
    # original HEAD before returning so the caller's branch context is
    # preserved.

    local BRANCH=$1
    if [[ -z "$BRANCH" ]]; then
        echo "find_matching_squashed_commit: no branch supplied" >&2
        return 1
    fi

    # Remember where we started so we can restore it later (may be detached).
    local ORIG_REF
    ORIG_REF=$(git symbolic-ref --quiet --short HEAD 2>/dev/null || git rev-parse --quiet --verify HEAD)

    # Switch to the branch being searched (quietly).
    git checkout --quiet "$BRANCH" || return 1

    local USER_EMAIL
    USER_EMAIL=$(git config user.email)

    local _xtrace_was_on=0
    case "$-" in *x*) _xtrace_was_on=1; set +x ;; esac

    for commit in $(git rev-list --author="$USER_EMAIL" --max-count=1000 main); do
        echo "Checking $commit..." >&2

        if git cherry-pick --quiet --no-commit "$commit" 2>/dev/null; then
            if git diff --cached --quiet && git diff --quiet; then
                echo "Found matching commit on main: $commit" >&2
                git reset --hard --quiet
                [[ $_xtrace_was_on -eq 1 ]] && set -x
                # Restore original HEAD before returning
                git cherry-pick --abort >/dev/null 2>&1 || true
                git checkout --quiet "$ORIG_REF" 2>/dev/null || git checkout --quiet -
                echo "$commit"
                return 0
            fi
        fi
        git cherry-pick --abort >/dev/null 2>&1 || true
        git reset --hard --quiet
    done

    [[ $_xtrace_was_on -eq 1 ]] && set -x
    git checkout --quiet "$ORIG_REF" 2>/dev/null || git checkout --quiet -
    echo "No matching squashed commit found on main" >&2
    return 1
}
